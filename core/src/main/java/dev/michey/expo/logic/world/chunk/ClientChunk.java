package dev.michey.expo.logic.world.chunk;

import dev.michey.expo.log.ExpoLogger;
import dev.michey.expo.logic.container.ExpoClientContainer;
import dev.michey.expo.logic.world.ClientWorld;
import dev.michey.expo.noise.BiomeType;
import dev.michey.expo.render.RenderContext;
import dev.michey.expo.server.main.logic.world.chunk.DynamicTilePart;
import dev.michey.expo.server.packet.P32_ChunkDataSingle;
import dev.michey.expo.util.ExpoShared;
import dev.michey.expo.util.Pair;

import java.util.Arrays;

import static dev.michey.expo.util.ExpoShared.*;

public class ClientChunk {

    // passed by server
    public int chunkX;
    public int chunkY;
    public BiomeType[] biomes;
    public ClientDynamicTilePart[][] dynamicTiles;
    public float[] grassColor;
    public float[][] ambientOcclusion;
    public int[] tileEntities;

    // SET BY CLIENT
    public Pair[][] layer1Displacement;

    // generated by client
    public boolean chunkContainsWater;
    public int chunkDrawBeginX;
    public int chunkDrawBeginY;
    public int chunkDrawEndX;
    public int chunkDrawEndY;
    public boolean visible;

    public void updateVisibility() {
        visible = RenderContext.get().inDrawBounds(this);
    }

    public ClientChunk(int chunkX, int chunkY, BiomeType[] biomes, DynamicTilePart[][] dynamicTiles, float[] grassColor, float[][] ambientOcclusion, int[] tileEntities) {
        this.chunkX = chunkX;
        this.chunkY = chunkY;
        this.biomes = biomes;
        this.dynamicTiles = convertToClient(dynamicTiles);
        this.grassColor = grassColor;
        this.ambientOcclusion = ambientOcclusion;
        this.tileEntities = tileEntities; // Could be null

        chunkDrawBeginX = ExpoShared.chunkToPos(chunkX);
        chunkDrawBeginY = ExpoShared.chunkToPos(chunkY);
        chunkDrawEndX = chunkDrawBeginX + CHUNK_SIZE;
        chunkDrawEndY = chunkDrawBeginY + CHUNK_SIZE;

        for(BiomeType t : biomes) {
            if(BiomeType.isWater(t)) {
                chunkContainsWater = true;
                break;
            }
        }

        if(chunkContainsWater) {
            layer1Displacement = new Pair[dynamicTiles.length][];

            for(int i = 0; i < layer1Displacement.length; i++) {
                var tiles = dynamicTiles[i];

                for(DynamicTilePart tile : tiles) {
                    int[] ids = tile.layerIds;

                    if(BiomeType.isWater(biomes[i]) && biomes[i] != BiomeType.OCEAN_DEEP && biomes[i] != BiomeType.PUDDLE && ids.length > 1) {
                        Pair[] array = new Pair[ids.length];

                        for(int a = 0; a < ids.length; a++) {
                            array[a] = idToDir(ids[a]);
                        }

                        layer1Displacement[i] = array;
                    }
                }
            }
        }
    }

    public void createTileEntityGridIfRequired() {
        if(tileEntities == null) {
            tileEntities = new int[ROW_TILES * ROW_TILES];
            Arrays.fill(tileEntities, -1);
        }
    }

    public void updateSingle(P32_ChunkDataSingle p) {
        this.dynamicTiles[p.tileArray][p.layer].updateFrom(p.tile);
        this.grassColor[p.tileArray] = p.grassColor;
        this.ambientOcclusion[p.tileArray] = p.ambientOcclusion;
        this.createTileEntityGridIfRequired();
        this.tileEntities[p.tileArray] = p.tileEntity;
    }

    public void update(BiomeType[] biomes, DynamicTilePart[][] individualTileData, float[] grassColor, float[][] ambientOcclusion, int[] tileEntities) {
        this.biomes = biomes;
        this.grassColor = grassColor;
        this.ambientOcclusion = ambientOcclusion;
        this.tileEntities = tileEntities;

        for(int i = 0; i < individualTileData.length; i++) {
            DynamicTilePart[] server = individualTileData[i];
            ClientDynamicTilePart[] client = this.dynamicTiles[i];

            for(int j = 0; j < server.length; j++) {
                client[j].updateFrom(server[j]);
            }
        }
    }

    private Pair<Integer, Integer> idToDir(int id) {
        int dirX = 0, dirY = 0;
        int del = id >= 90 ? 90 : 46;

        switch(id - del) {
            case 3, 6 -> {
                dirX = 0;
                dirY = -1;
            }
            case 2 -> {
                dirX = 1;
                dirY = -1;
            }
            case 9, 15 -> {
                dirX = -1;
                dirY = 0;
            }
            case 4, 10 -> {
                dirX = 1;
                dirY = 0;
            }
            case 7 -> {
                dirX = -1;
                dirY = -1;
            }
            case 12 -> {
                dirX = 1;
                dirY = 1;
            }
            case 13, 16 -> {
                dirX = 0;
                dirY = 1;
            }
            case 17 -> {
                dirX = -1;
                dirY = 1;
            }
            case 18, 19, 20, 21 -> {
                dirX = 0;
                dirY = 0;
            }
        }

        return new Pair<>(dirX, dirY);
    }

    private ClientDynamicTilePart[][] convertToClient(DynamicTilePart[][] tiles) {
        ClientDynamicTilePart[][] array = new ClientDynamicTilePart[tiles.length][];
        float startX = ExpoShared.chunkToPos(chunkX);
        float startY = ExpoShared.chunkToPos(chunkY);

        for(int i = 0; i < tiles.length; i++) {
            DynamicTilePart[] server = tiles[i];
            int x = i % ROW_TILES;
            int y = i / ROW_TILES;

            array[i] = new ClientDynamicTilePart[server.length];

            for(int j = 0; j < server.length; j++) {
                array[i][j] = new ClientDynamicTilePart(this, startX + TILE_SIZE * x, startY + TILE_SIZE * y, server[j]);
            }
        }

        return array;
    }

}