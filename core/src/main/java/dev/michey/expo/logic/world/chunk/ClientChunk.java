package dev.michey.expo.logic.world.chunk;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.MathUtils;
import dev.michey.expo.assets.ExpoAssets;
import dev.michey.expo.noise.BiomeType;
import dev.michey.expo.util.ExpoShared;
import dev.michey.expo.util.Pair;

import java.util.Arrays;

import static dev.michey.expo.util.ExpoShared.CHUNK_SIZE;

public class ClientChunk {

    // passed by server
    public int chunkX;
    public int chunkY;
    public BiomeType[] biomes;
    public int[][] layer0;
    public int[][] layer1;
    public int[][] layer2;
    // SET BY CLIENT
    public final TextureRegion[][] layer0Tex;
    public final TextureRegion[][] layer1Tex;
    public final TextureRegion[][] layer2Tex;
    public Pair[][] layer1Displacement;

    // generated by client
    public boolean chunkContainsWater;
    public int chunkDrawBeginX;
    public int chunkDrawBeginY;
    public int chunkDrawEndX;
    public int chunkDrawEndY;

    private void updateLayer0Tex(int[][] newLayer0, boolean skipCheck) {
        if(!skipCheck) {
            for(int i = 0 ; i < newLayer0.length; i++) {
                int[] newIds = newLayer0[i];
                boolean updateTex = !Arrays.equals(newIds, layer0[i]);
                if(updateTex) _genLayer0Tex(newIds, i);
            }
        } else {
            for(int i = 0 ; i < layer0.length; i++) {
                int[] current = layer0[i];
                _genLayer0Tex(current, i);
            }
        }

        if(!skipCheck) this.layer0 = newLayer0;
    }

    private void updateLayer1Tex(int[][] newLayer1, boolean skipCheck) {
        if(!skipCheck) {
            for(int i = 0 ; i < newLayer1.length; i++) {
                int[] newIds = newLayer1[i];
                boolean updateTex = !Arrays.equals(newIds, layer1[i]);
                if(updateTex) _genLayer1Tex(newIds, i);
            }
        } else {
            for(int i = 0 ; i < layer1.length; i++) {
                int[] current = layer1[i];
                _genLayer1Tex(current, i);
            }
        }

        if(!skipCheck) this.layer1 = newLayer1;
    }

    private void updateLayer2Tex(int[][] newLayer2, boolean skipCheck) {
        if(!skipCheck) {
            for(int i = 0 ; i < newLayer2.length; i++) {
                int[] newIds = newLayer2[i];
                boolean updateTex = !Arrays.equals(newIds, layer2[i]);
                if(updateTex) _genLayer2Tex(newIds, i);
            }
        } else {
            for(int i = 0 ; i < layer2.length; i++) {
                int[] current = layer2[i];
                _genLayer2Tex(current, i);
            }
        }

        if(!skipCheck) this.layer2 = newLayer2;
    }

    private void _genLayer0Tex(int[] ids, int i) {
        layer0Tex[i] = new TextureRegion[ids.length];

        for(int j = 0; j < ids.length; j++) {
            int index = ids[j];
            layer0Tex[i][j] = ExpoAssets.get().getTileSheet().getTilesetTextureMap().get(index);
        }
    }

    private void _genLayer1Tex(int[] ids, int i) {
        layer1Tex[i] = new TextureRegion[ids.length];

        for(int j = 0; j < ids.length; j++) {
            int index = ids[j];

            if(index == 1 && MathUtils.random() < 0.66f) {
                layer1Tex[i][j] = ExpoAssets.get().getTileSheet().getRandomVariation(index);
            } else {
                layer1Tex[i][j] = ExpoAssets.get().getTileSheet().getTilesetTextureMap().get(index);
            }
        }
    }

    private void _genLayer2Tex(int[] ids, int i) {
        layer2Tex[i] = new TextureRegion[ids.length];

        for(int j = 0; j < ids.length; j++) {
            int index = ids[j];
            layer2Tex[i][j] = ExpoAssets.get().getTileSheet().getTilesetTextureMap().get(index);
        }
    }

    public ClientChunk(int chunkX, int chunkY, BiomeType[] biomes, int[][] layer0, int[][] layer1, int[][] layer2) {
        this.chunkX = chunkX;
        this.chunkY = chunkY;
        this.biomes = biomes;
        this.layer0 = layer0;
        this.layer1 = layer1;
        this.layer2 = layer2;

        layer0Tex = new TextureRegion[layer0.length][];
        layer1Tex = new TextureRegion[layer1.length][];
        layer2Tex = new TextureRegion[layer2.length][];
        updateLayer0Tex(layer0, true);
        updateLayer1Tex(layer1, true);
        updateLayer2Tex(layer2, true);

        chunkDrawBeginX = ExpoShared.chunkToPos(chunkX);
        chunkDrawBeginY = ExpoShared.chunkToPos(chunkY);
        chunkDrawEndX = chunkDrawBeginX + CHUNK_SIZE;
        chunkDrawEndY = chunkDrawBeginY + CHUNK_SIZE;

        for(BiomeType t : biomes) {
            if(BiomeType.isWater(t)) {
                chunkContainsWater = true;
                break;
            }
        }

        if(chunkContainsWater) {
            layer1Displacement = new Pair[layer1.length][];

            for(int i = 0; i < layer1Displacement.length; i++) {
                int[] ids = layer1[i];

                if(BiomeType.isWater(biomes[i]) && biomes[i] != BiomeType.OCEAN_DEEP && ids.length > 1) {
                    Pair[] array = new Pair[ids.length];

                    for(int a = 0; a < ids.length; a++) {
                        array[a] = idToDir(ids[a]);
                    }

                    layer1Displacement[i] = array;
                }
            }
        }
    }

    public void update(BiomeType[] biomes, int[][] layer0, int[][] layer1, int[][] layer2) {
        this.biomes = biomes;
        if(!Arrays.deepEquals(layer0, this.layer0)) updateLayer0Tex(layer0, false);
        if(!Arrays.deepEquals(layer1, this.layer1)) updateLayer1Tex(layer1, false);
        if(!Arrays.deepEquals(layer2, this.layer2)) updateLayer2Tex(layer2, false);
    }

    private Pair<Integer, Integer> idToDir(int id) {
        int dirX = 0, dirY = 0;
        int del = id >= 90 ? 90 : 46;

        switch(id - del) {
            case 3, 6 -> {
                dirX = 0;
                dirY = -1;
            }
            case 2 -> {
                dirX = 1;
                dirY = -1;
            }
            case 9, 15 -> {
                dirX = -1;
                dirY = 0;
            }
            case 4, 10 -> {
                dirX = 1;
                dirY = 0;
            }
            case 7 -> {
                dirX = -1;
                dirY = -1;
            }
            case 12 -> {
                dirX = 1;
                dirY = 1;
            }
            case 13, 16 -> {
                dirX = 0;
                dirY = 1;
            }
            case 17 -> {
                dirX = -1;
                dirY = 1;
            }
            case 18, 19, 20, 21 -> {
                dirX = 0;
                dirY = 0;
            }
        }

        return new Pair<>(dirX, dirY);
    }

}