package dev.michey.expo.logic.world.chunk;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import dev.michey.expo.assets.ExpoAssets;
import dev.michey.expo.assets.TileMapping;
import dev.michey.expo.noise.BiomeType;
import dev.michey.expo.util.ExpoShared;

import static dev.michey.expo.log.ExpoLogger.log;
import static dev.michey.expo.util.ExpoShared.CHUNK_SIZE;
import static dev.michey.expo.util.ExpoShared.ROW_TILES;

public class ClientChunk {

    // passed by server
    public int chunkX;
    public int chunkY;
    public BiomeType[] biomeData;
    public int[] tileTextureData;
    public TextureRegion[] tileTextureRegionData;
    public boolean[] waterLoggedData;

    // generated by client
    public boolean chunkContainsWater;
    public TextureRegion[] tileShadowData;
    public int[] tileShadowDataOffset;

    public int chunkDrawBeginX;
    public int chunkDrawBeginY;
    public int chunkDrawEndX;
    public int chunkDrawEndY;

    public ClientChunk(int chunkX, int chunkY, BiomeType[] biomeData, int[] tileTextureData, boolean[] waterLoggedData) {
        this.chunkX = chunkX;
        this.chunkY = chunkY;
        this.biomeData = biomeData;
        this.tileTextureData = tileTextureData;
        this.waterLoggedData = waterLoggedData;

        chunkDrawBeginX = ExpoShared.chunkToPos(chunkX);
        chunkDrawBeginY = ExpoShared.chunkToPos(chunkY);
        chunkDrawEndX = chunkDrawBeginX + CHUNK_SIZE;
        chunkDrawEndY = chunkDrawBeginY + CHUNK_SIZE;

        tileTextureRegionData = new TextureRegion[tileTextureData.length];

        for(int i = 0; i < tileTextureRegionData.length; i++) {
            TileMapping tm = ExpoAssets.get().biomeToTileMapping(biomeData[i]);

            if(tm != null) {
                tileTextureRegionData[i] = tm.getRandom(tileTextureData[i]);
            }
        }

        for(BiomeType t : biomeData) {
            if(BiomeType.isWater(t)) {
                chunkContainsWater = true;
                break;
            }
        }

        if(!chunkContainsWater) {
            for(boolean wl : waterLoggedData) {
                if(wl) {
                    chunkContainsWater = true;
                    break;
                }
            }
        }

        if(chunkContainsWater) {
            tileShadowData = new TextureRegion[ROW_TILES * ROW_TILES];
            tileShadowDataOffset = new int[ROW_TILES * ROW_TILES];

            for(int i = 0; i < tileTextureRegionData.length; i++) {
                TileMapping tm = ExpoAssets.get().biomeToTileMapping(biomeData[i]);
                if(tm == null) continue;

                if(waterLoggedData[i] && tm.supportsShadows(tileTextureData[i])) {
                    var pair = tm.getShadow(tileTextureData[i]);
                    tileShadowData[i] = pair.key;
                    tileShadowDataOffset[i] = pair.value;
                }
            }
        }
    }

}