package dev.michey.expo.logic.world.chunk;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import dev.michey.expo.assets.ExpoAssets;
import dev.michey.expo.noise.BiomeType;
import dev.michey.expo.util.ExpoShared;
import dev.michey.expo.util.Pair;

import static dev.michey.expo.util.ExpoShared.CHUNK_SIZE;

public class ClientChunk {

    // passed by server
    public int chunkX;
    public int chunkY;
    public final BiomeType[] biomes;
    public final int[][] layer0;
    public final int[][] layer1;
    public final int[][] layer2;
    // SET BY CLIENT
    public final TextureRegion[][] layer0Tex;
    public final TextureRegion[][] layer1Tex;
    public final TextureRegion[][] layer2Tex;
    public Pair[][] layer1Displacement;

    // generated by client
    public boolean chunkContainsWater;
    public int chunkDrawBeginX;
    public int chunkDrawBeginY;
    public int chunkDrawEndX;
    public int chunkDrawEndY;

    public ClientChunk(int chunkX, int chunkY, BiomeType[] biomes, int[][] layer0, int[][] layer1, int[][] layer2) {
        this.chunkX = chunkX;
        this.chunkY = chunkY;
        this.biomes = biomes;
        this.layer0 = layer0;
        this.layer1 = layer1;
        this.layer2 = layer2;

        layer0Tex = new TextureRegion[layer0.length][];
        layer1Tex = new TextureRegion[layer1.length][];
        layer2Tex = new TextureRegion[layer2.length][];
        ExpoAssets assets = ExpoAssets.get();

        {
            for(int i = 0 ; i < layer0.length; i++) {
                int[] current = layer0[i];
                layer0Tex[i] = new TextureRegion[current.length];

                for(int j = 0; j < current.length; j++) {
                    int index = current[j];
                    layer0Tex[i][j] = assets.getTileSheet().getTilesetTextureMap().get(index);
                }
            }
        }

        {
            for(int i = 0 ; i < layer1.length; i++) {
                int[] current = layer1[i];
                layer1Tex[i] = new TextureRegion[current.length];

                for(int j = 0; j < current.length; j++) {
                    int index = current[j];
                    layer1Tex[i][j] = assets.getTileSheet().getTilesetTextureMap().get(index);
                }
            }
        }

        {
            for(int i = 0 ; i < layer2.length; i++) {
                int[] current = layer2[i];
                layer2Tex[i] = new TextureRegion[current.length];

                for(int j = 0; j < current.length; j++) {
                    int index = current[j];
                    layer2Tex[i][j] = assets.getTileSheet().getTilesetTextureMap().get(index);
                }
            }
        }

        chunkDrawBeginX = ExpoShared.chunkToPos(chunkX);
        chunkDrawBeginY = ExpoShared.chunkToPos(chunkY);
        chunkDrawEndX = chunkDrawBeginX + CHUNK_SIZE;
        chunkDrawEndY = chunkDrawBeginY + CHUNK_SIZE;

        for(BiomeType t : biomes) {
            if(BiomeType.isWater(t)) {
                chunkContainsWater = true;
                break;
            }
        }

        if(chunkContainsWater) {
            layer1Displacement = new Pair[layer1.length][];

            for(int i = 0; i < layer1Displacement.length; i++) {
                int[] ids = layer1[i];

                if(BiomeType.isWater(biomes[i]) && biomes[i] != BiomeType.OCEAN_DEEP && ids.length > 1) {
                    Pair[] array = new Pair[ids.length];

                    for(int a = 0; a < ids.length; a++) {
                        array[a] = idToDir(ids[a]);
                    }

                    layer1Displacement[i] = array;
                }
            }
        }
    }

    private Pair<Integer, Integer> idToDir(int id) {
        int dirX = 0, dirY = 0;

        switch(id - 46) {
            case 3, 6 -> {
                dirX = 0;
                dirY = -1;
            }
            case 2 -> {
                dirX = 1;
                dirY = -1;
            }
            case 9, 15 -> {
                dirX = -1;
                dirY = 0;
            }
            case 4, 10 -> {
                dirX = 1;
                dirY = 0;
            }
            case 7 -> {
                dirX = -1;
                dirY = -1;
            }
            case 12 -> {
                dirX = 1;
                dirY = 1;
            }
            case 13, 16 -> {
                dirX = 0;
                dirY = 1;
            }
            case 17 -> {
                dirX = -1;
                dirY = 1;
            }
            case 18, 19, 20, 21 -> {
                dirX = 0;
                dirY = 0;
            }
        }

        return new Pair<>(dirX, dirY);
    }

}